# 실험 2: 도구 연동 및 Auto-Repair 강건성

## 실험 목표

LLM이 자동 생성한 어댑터 코드의 **첫 실행 성공률(Baseline)**과 **Auto-Repair 적용 후 성공률(Pass@k)**을 비교

---

## 현재 상태

| 항목 | 상태 |
|------|------|
| 등록된 도구 | 3개 (create_enclosing_walls, create_outer_walls, parallel_optimizer) |
| Auto-Repair | **비활성** (MAX_AUTO_REPAIR_ATTEMPTS = 0) |
| 테스트 BOP | 1개 (test_bop_bicycle.json, 자전거 조립 5공정) |
| 로그 시스템 | 자동 기록 (`data/tool_logs/`) |

---

## Phase 1: 도구 확보 (분석 도구 7~10개 추가)

현재 3개로는 논문 실험에 부족. 다양한 I/O 패턴을 가진 분석 도구를 **7~10개 추가** 필요.

### 추천 도구 목록

| # | 도구명 | 기능 | I/O 난이도 |
|---|--------|------|-----------|
| 1 | bottleneck_analyzer | 병목 공정 식별 (cycle_time 기반) | 쉬움 |
| 2 | line_balance_calculator | 라인 밸런싱 효율 계산 | 쉬움 |
| 3 | equipment_utilization | 설비 가동률 산출 | 중간 |
| 4 | process_distance_analyzer | 공정 간 물리적 거리 분석 | 중간 |
| 5 | worker_skill_matcher | 작업자-공정 스킬 매칭 분석 | 중간 |
| 6 | material_flow_analyzer | 자재 투입량/흐름 분석 | 중간 |
| 7 | safety_zone_checker | 장애물-공정 간 안전 거리 검증 | 중간 |
| 8 | takt_time_optimizer | 택트 타임 기반 UPH 최적화 | 어려움 |
| 9 | energy_estimator | 설비별 에너지 소비 추정 | 어려움 |
| 10 | layout_compactor | 공정 레이아웃 압축 재배치 | 어려움 |

### 수행 방법

- 각 도구를 **독립 Python 스크립트**로 작성 (argparse로 `--input`, `--output` 받는 형태)
- 스크립트 자체는 정상 동작하도록 작성 (도구 로직이 아니라 **어댑터에서 에러가 발생**하는 것이 실험 대상)
- GDP 프론트엔드 또는 API로 등록하여 LLM이 어댑터를 자동 생성하도록 함

---

## Phase 2: BOP 시나리오 확보 (5~8개)

다양한 구조의 BOP 데이터 필요.

| # | BOP 시나리오 | 특성 |
|---|-------------|------|
| 1 | 자전거 조립 (기존) | 5공정, 병렬 1개, 장애물 4개 |
| 2 | EV 배터리 셀 | 8~10공정, 선형 흐름 |
| 3 | SMT 라인 | 5~7공정, 검사 분기 |
| 4 | 타이어 제조 | 6~7공정, 다양한 설비 유형 |
| 5 | 세탁기 조립 | 6~8공정, 병렬 2~3개 |
| 6 | 최소 BOP | 2공정 (엣지 케이스) |
| 7 | 대형 BOP | 12~15공정 (스케일 테스트) |
| 8 | 복합 DAG | 분기+합류 구조 |

### 수행 방법

- GDP 채팅으로 각 제품의 BOP를 생성 → JSON 저장
- 또는 실험1의 LLM 생성 결과를 BOP 형식으로 변환

---

## Phase 3: 실험 실행

### 3-1. Baseline 측정 (No Repair)

```python
# executor.py
MAX_AUTO_REPAIR_ATTEMPTS = 0
```

1. 각 도구를 **새로 등록** (LLM이 어댑터 자동 생성)
2. 각 BOP 시나리오에 대해 실행
3. 성공/실패 기록 → **Pass@1 (Baseline)** 산출

**데이터 수집:**
- 도구 N개 × BOP M개 = N×M 회 실행
- 각 실행의 success, error_type, error_message 기록

### 3-2. Auto-Repair 측정 (k=1,2,3)

```python
# executor.py
MAX_AUTO_REPAIR_ATTEMPTS = k  # k=1, 2, 3
```

1. **Baseline에서 실패한 케이스**를 대상으로 재실행
2. k=1, k=2, k=3 각각 실행
3. 성공/실패 + repair_attempts 기록 → **Pass@k** 산출

**주의:** 어댑터가 수리되면 레지스트리에 저장되므로, 각 k 테스트 전에 **원본 어댑터로 복원** 필요.

### 3-3. 실험 매트릭스

```
         BOP1  BOP2  BOP3  BOP4  BOP5  ...
Tool 1    ✓/✗   ✓/✗   ✓/✗   ✓/✗   ✓/✗
Tool 2    ✓/✗   ✓/✗   ✓/✗   ✓/✗   ✓/✗
Tool 3    ✓/✗   ✓/✗   ✓/✗   ✓/✗   ✓/✗
...
Tool 10   ✓/✗   ✓/✗   ✓/✗   ✓/✗   ✓/✗
```

총 실행 횟수: **10도구 × 8BOP × 4조건(k=0,1,2,3) = 320회**

---

## Phase 4: 결과 분석

### 핵심 지표

| 지표 | 계산 방법 |
|------|----------|
| Pass@1 (Baseline) | k=0에서 성공 횟수 / 전체 |
| Pass@2 | k≤1에서 성공 횟수 / 전체 |
| Pass@3 | k≤2에서 성공 횟수 / 전체 |
| 에러 유형 분포 | KeyError, TypeError, ValueError 등 비율 |
| 수리 수렴 속도 | 평균 몇 회 만에 수리 성공? |
| 도구 난이도별 차이 | 쉬움/중간/어려움별 Pass@k |

### 논문 Table 형태

| 조건 | Pass@k | 평균 수리 횟수 |
|------|--------|--------------|
| Baseline (No Repair) | ??% | - |
| GDP (k=1) | ??% | ?.? |
| GDP (k=2) | ??% | ?.? |
| GDP (k=3) | ??% | ?.? |

---

## Phase 5: 자동화 스크립트

실험1처럼 `ex2/run_experiment.py`를 작성하여 자동화.

### 디렉터리 구조

```
ex2/
├── tools/                    # 분석 도구 스크립트들
│   ├── bottleneck_analyzer.py
│   ├── line_balance_calculator.py
│   ├── equipment_utilization.py
│   ├── process_distance_analyzer.py
│   ├── worker_skill_matcher.py
│   ├── material_flow_analyzer.py
│   ├── safety_zone_checker.py
│   ├── takt_time_optimizer.py
│   ├── energy_estimator.py
│   └── layout_compactor.py
├── bop_scenarios/            # 테스트 BOP JSON들
│   ├── bicycle.json
│   ├── ev_battery.json
│   ├── smt_line.json
│   ├── tire.json
│   ├── washing_machine.json
│   ├── minimal.json
│   ├── large_scale.json
│   └── complex_dag.json
├── run_experiment.py         # 자동화 실험 스크립트
└── results/                  # 결과 저장
    ├── ex2_detail_YYYYMMDD_HHMMSS.json
    └── ex2_summary_YYYYMMDD_HHMMSS.json
```

---

## 우선순위 순서

| 순서 | 작업 | 예상 소요 | 비고 |
|:---:|------|----------|------|
| 1 | 도구 스크립트 작성 (Phase 1) | 가장 오래 걸림 | 핵심 |
| 2 | BOP 시나리오 생성 (Phase 2) | GDP 채팅으로 빠르게 가능 | |
| 3 | 실험 자동화 스크립트 작성 (Phase 5) | | |
| 4 | Baseline 측정 (Phase 3-1) | | |
| 5 | Auto-Repair 측정 (Phase 3-2) | | |
| 6 | 결과 분석 및 논문 반영 (Phase 4) | | |

---

## 기술 참고사항

### Auto-Repair 설정 위치

```
app/tools/executor.py (Line 23-25)
├── SUBPROCESS_TIMEOUT_SEC = 60
├── MAX_AUTO_REPAIR_ATTEMPTS = 0   ← 이 값을 k로 변경
└── MAX_SCRIPT_REPAIR_ATTEMPTS = 0  ← 스크립트 자체 수리 (별도)
```

### Auto-Repair 대상 범위

| 대상 | 수리 가능 | 비고 |
|------|:---------:|------|
| Pre-processor (convert_bop_to_input) | O | BOP→도구 입력 변환 코드 |
| Post-processor (apply_result_to_bop) | O | 도구 결과→BOP 반영 코드 |
| 도구 스크립트 자체 | X | 외부 스크립트 영역 |

### 로그 위치

```
data/tool_logs/{tool_id}/{timestamp}.json
```

각 실행마다 자동 기록됨:
- success, error_type, error_message
- auto_repair_attempts, auto_repair_success
- execution_time_sec, stdout, stderr
